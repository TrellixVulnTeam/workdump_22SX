% File example.tex
% Contact: simonnet@ecole.ensicaen.fr
%
% version 1.0 (July 24, 2009)
% version 1.1 (September 3, 2009)
% add using of the optional command: \secondauthoraddr

\documentclass[10pt]{article}

\input{../template/preamble.tex}

%other package

% vectorial font
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{times}
\usepackage{amsmath}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\begin{document}
\noindent

% This should produce references in the order they appear
\bibliographystyle{ieeetr}

\title{The RSA Algorithm}

\authorname{John Paul S. Guzman}
\authoraddr{Mathematics Department, De La Salle University, 2401 Taft Ave., Manila 0922, Philippines}

\maketitle


\abstract
Encryption is the process of scrambling information in such a way that it can only be read by select individuals. It is an essential tool as we rely on the internet to accomplish various activities such as online banking, transactions, and private messaging. In these activities, we are often required to communicate sensitive information like passwords, credit card information, home addresses, etc. This paper discusses the RSA algorithm, its mathematical foundations, and how it is used to protect sensitive information.
\keywords
Cryptography, Internet security, Prime numbers.


\section{Introduction}
The RSA algorithm is one of the earliest implementations of an asymmetric cryptosystem \cite{rivest1978method}. Asymmetric encryption differs from classical encryption as it uses separate keys for encryption (public key) and decryption (private key) \cite{diffie1976new}. This allows the users to establish a private communication over a public channel. Moreover, it secures sensitive data from so-called “man-in-the-middle“ attacks wherein malicious third-party eavesdrops on the communication between two parties with the intent of stealing information \cite{stallings1999cryptography}. Another key feature of RSA is the ability to create digital signatures. Similar to a physical signature, a digital signature provides a way to prove that a message originated from the sender along with the means to show that the message was not tampered with \cite{diffie1976new}. 

We will discuss how RSA: (a) encrypts a message into ciphertext, (b) decrypts ciphertext back to plaintext, (c) generates digital signatures. Then, we show the correctness of these procedures using Euler’s theorem along with the properties of congruences. Lastly, we will apply these techniques in a sample scenario.


\section{Cryptographic Procedures}
We begin with generating the public and private keys. We need to choose two large distinct prime numbers $p$ and $q$ at random. Let $n$ be the product of $p$ and $q$. Next, pick a large random integer $d$ that is relatively prime to $\phi(n)$ where $\phi$ is the Euler totient function. Finally, we choose $e$ to be the multiplicative inverse of $d$ modulo $\phi(n)$.
\begin{equation*}
	e d \equiv 1 \mod \phi(n).
\end{equation*}

We know that such an $e$ exists since $d$ is relatively prime to $\phi(n)$. The pair $(e, n)$ will serve as the public key, while the pair $(d, n)$ will serve as the private key.

Let $M$ be a plaintext message encoded as a number. We insist that $M < n$. In the case where $M \geq n$, we will split $M$ into multiple chunks and send them separately. Furthermore, we insist that $M$ is relatively prime to $n$. In practice, this is a safe assumption since it is unlikely that $M$ is a multiple of $p$ or $q$. Regardless, we could easily check for this case since we have access to $p$ and $q$. If so, we can simply split $M$ further or add some padding until it becomes relatively prime to $n$.

We generate the ciphertext $C$ by raising $M$ to $e$th power then taking modulo $n$. We can decipher $C$ to the plaintext $D$ by raising $C$ to the $d$th power then taking modulo $n$. Lastly, we can create the digital signature $S$ by raising $M$ to the $d$th power then taking modulo $n$.
\begin{align*}
    C \equiv M^e \mod n.
 \\ D \equiv C^d \mod n.
 \\ S \equiv M^d \mod n.
\end{align*}


\section{Mathematical Foundations}
To illustrate the correctness of these operations, we first need to discuss some results in number theory.

\begin{theorem}
\label{cong_thms}
    If $a \equiv b \mod n$, then $c a \equiv c b \mod n$ and $a^k \equiv b^k \mod n$ for any positive integer $k$.
\end{theorem}

\begin{theorem}
    If $a$ and $b$ are relatively prime with $a \mid c$ and $b  \mid c$, then $a b \mid c$.
\end{theorem}

\begin{corollary}
\label{cong_rel-prime}
    If $m$ and $n$ are relatively prime with $a \equiv b \mod m$ and $a \equiv b \mod n$, then $a \equiv b \mod m n$.
\end{corollary}

\begin{theorem}
\label{phi_prime}
    If $p$ is prime, then $\phi(p) = p - 1$.
\end{theorem}

\begin{theorem}
\label{phi_mult}
    If $a$ and $b$ are relatively prime, then $\phi(a b) = \phi(a) \phi(b)$.
\end{theorem}

\begin{theorem}[Euler's theorem \cite{burton2006elementary}]
\label{euler}
    If $a$ is relatively prime to $b$, then $a^{\phi(b)} \equiv 1 \mod b$.
\end{theorem}

We can now show that decrypting the ciphertext does indeed yield the original message. By the choice of $e$ and $d$,
\begin{equation}
\label{ed_id}
    e d = k \phi(n) + 1 \text{ for some integer }k.
\end{equation}

\noindent Since $p$ and $q$ are distinct primes, we can use \ref{phi_prime} and \ref{phi_mult} to obtain
\begin{equation}
    \phi(n) = \phi(p q) = \phi(p) \phi(q) = (p - 1) (q - 1).
\end{equation}

\noindent Since $M$ and $p$ are relatively prime, we can apply \ref{euler} to obtain
\begin{equation}
    M^{\phi(p)} \equiv M^{p - 1} \equiv 1 \mod p.
\end{equation}

\noindent Furthermore, by \ref{cong_thms},
\begin{align}
    M^{k \phi(n)} \equiv (M^{p - 1})^{k (q - 1)} \equiv 1^{k (q - 1)} \equiv 1 \mod p.
 \\ \label{Mmodp}
    M^{k \phi(n) + 1} \equiv M (1) \equiv M \mod p.
\end{align}

\noindent We can apply similar arguments for $q$,
\begin{equation}
    \label{Mmodq}
    M^{k \phi(n) + 1} \equiv M \mod q.
\end{equation}

\noindent Since $p$ and $q$ are distinct primes, we can apply \ref{cong_rel-prime} to \ref{Mmodp} and \ref{Mmodq}.
\begin{equation}
    \label{Mmodn}
    M^{k \phi(n) + 1} \equiv M \mod n.
\end{equation}

\noindent The desired result is obtained by \ref{ed_id} and \ref{Mmodn}.
\begin{equation}
    \label{CD_id}
    D \equiv C^d \equiv (M^e)^d  \equiv M^{e d} \equiv M^{k \phi(n) + 1} \equiv M \mod n.
\end{equation}

\noindent A similar result is used in the implementation of signatures which states that decryption followed by encryption will also result in the original message.
\begin{equation}
    \label{SE_id}
    S^e \equiv (M^d)^e \equiv M^{e d} \equiv M \mod n.
\end{equation}


\section{Application in RSA}
We illustrate the application of these results in the following scenario. Suppose that Alice wants to send a message $M$ to Bob. Bob will generate his public key $(e_B, n_B)$ and private key $(d_B, n_B)$, then publish only the public key. Alice would take Bob’s public key, use it to create the ciphertext $C \equiv M^{e_B} \mod n_B$, then send it over. Bob can then recover the original message by $M \equiv C^{d_B} \mod n_B$ as in \ref{CD_id}. Now suppose Eve was eavesdropping in their conversation. This means that she would have a copy of the ciphertext $C$ and the public key $(e_B, n_B)$. However, she will be unable to decipher $C$ since she does not have access to $d_B$. It has been conjectured in \cite{rivest1978method} that finding $d_B$ from $(e_B, n_B)$ requires an exhaustive search, and so it is unfeasible for sufficiently large values of $n_B$.

Hence, we are successful in establishing a private conversation over a public channel. This bypasses one of the biggest problems in symmetric encryption, namely, key distribution. This issue is due to the fact that two parties have to agree on which keys to use for encryption and decryption. If the same key is used for both encryption and decryption, then Eve can simply make a copy of this key during the phase where Alice and Bob were agreeing on the key. Eve will then be able to decipher all future communication between Alice and Bob.

Next, we consider the scenario where Alice wants to send a signed message $M$ to Bob. Alice can create a signature for this message by $S \equiv M^{d_A} \mod n$. She can send $S$ as an encrypted message to Bob as in the previous scenario, i.e., $S$ is encrypted by Alice with Bob's public key, then decrypted by Bob with his private key. Bob can recover the message from the signature by $M \equiv S^{e_A}$ as in \ref{SE_id}. 

We can confidently say that the message came from Alice since only she has access to $d_A$, and so only she could have generated the signature $S$. Furthermore, we can be confident that Bob did not modify the message $M$ into a tampered message $M'$. This is due to the fact that he is unable to produce the corresponding signature $S'$ for $M'$ since he does not have access to $d_A$. In other words, his knowledge of both $M$ and $S$ cannot be used to create forgeries.


\section{Conclusions}
we have to do


\bibliography{IEEEabrv, icdp2009}

\end{document}
